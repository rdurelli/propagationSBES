%!TEX root = /Users/rafaeldurelli/Dropbox/Artigos Elaborados/KDM propagation_2015/sbes_2015_kdm_propagation/sbes2015_kdm_propagation.tex

\section{Discussion}\label{sec:a_brief_discussion}

The focus of our paper is the demonstration of propagation that must be performed in different static representations (views) of a given system. This means that we are not concerned with dynamic parts.
As stated earlier, previous research has demonstrated concerns about the propagation of changes when modifications are made in models. However, the largest of them are concentrated in the propagation of changes between different metamodels. As KDM is a integrated model that can be seen as a set of metamodels, where all of them are somehow connected by means of associations. This is because a certain model element is used in several places in general is referenced by its \textit{id} without having to be duplicated in multiple locations. However, as stated before, to the best of our knowledge, up to this moment, there is no research concentrated on investigating change propagation in KDM. We claim that by using our approach the modernization engineers can concentrate just on the development of the refactorings, without worrying about the change propagation, which is a time-consuming and error-prone task.


%Some partial change propagations are already developed by MoDisco\footnote{https://eclipse.org/MoDisco/} plugin. For example, when a particular model element is removed, its \textit{id} is removed from all the other places that it is used. This is considered a partial propagation, because it can, in most cases, inserting inconsistencies in the model. However, when dealing with specific refactorings it is important to keep all KDM levels synchronized 

During the elaboration of this research we realized that some propagations can also be considered as refactoring and vice versa. What characterize them is how they are used in a specific moment and not the implementation by itself. This is like having a set of refactoring that anyone can trigger anyone. When this is the case, the modernization engineer can directly apply both, unlikely propagations which clearly cannot be directly applied from the user, as it is shown in~\cite{ICSOFT2014_Winetzhammer}. This is generally the case for moving refactorings, as the moving of an element from a container to another is independent of both the container and their abstraction level. For example, suppose the existence of a class C1 belonging to a package P1. Consider also that C1 is the implementation of a business rule B1 which is inside a scenario S1 and that the package P1 is the implementation of the Scenario S1. So, C1 = B1 and P1 = S1. If the \textit{Move Class} refactoring is applied to transfer the class C1 to package P2, a natural propagation is to transfer the business rule B1 to another scenario. However, if the modernization engineer is using a modeling environment which provides a business rule view, (s)he could also have available for him(her) a moving business rule refactoring. In this case, the natural propagation would be to transfer the corresponding classes from one package to another. Therefore, we can see that in some cases there is bidirectional flow, which can be started from any point. 
%
%
%
The most important thing about this discussion is that this categorization lead us to make good designs in terms of refactorings and propagations. That is, for refactorings that fall in this category, it is very important to implement them as separated and decoupled modules which can be called directly from the user. So, all of our refactorings were implemented like that. 
