%!TEX root = /Users/rafaeldurelli/Dropbox/Artigos Elaborados/KDM propagation_2015/sbes_2015_kdm_propagation/sbes2015_kdm_propagation.tex


The focus of our paper is the demonstration of propagation that must be performed in different static representations (views) of a given system. This means that we are not concerned with dynamic parts. As stated earlier, previous research has demonstrated concerns about the propagation of changes when modifications are made in models. However, the largest of them are concentrated in the propagation of changes between different meta-models. Otherwise we are interested in propagation of changes in different KDM abstraction views to keep them synchronized after a specific refactoring.   
%
%
We claim that by using our approach the modernization engineers can concentrate just on the development of the refactorings, without worrying about the change propagation, which is a time-consuming and error-prone task. 

As KDM is a integrated model that can be seen as a family of meta-models, where all of them are somehow connected by means of associations a certain model element is used in several places in general is referenced by its \textit{id} without having to be duplicated in multiple locations. This means that by applying the refactoring \textit{Rename X}, where X is any KDM elements the propagation would be performed automatically. During the elaboration of this research we also realized that some propagations can also be considered as refactoring and vice versa. What characterize them is how they are used in a specific moment and not the implementation by itself. This is like having a set of refactoring that anyone can trigger anyone. When this is the case, the modernization engineer can directly apply both, unlike propagations which clearly cannot be directly applied from the user, as it is shown in~\cite{ICSOFT2014_Winetzhammer}. This is generally the case for moving refactorings, as the moving of an element from a container to another is independent of both the container and their abstraction level. For example, suppose the existence of a class C1 belonging to a package P1. Consider also that C1 is the implementation of a business rule B1 which is inside a scenario S1 and that the package P1 is the implementation of the Scenario S1. So, C1 = B1 and P1 = S1. If the \textit{Move Class} refactoring is applied to transfer the class C1 to package P2, a natural propagation is to transfer the business rule B1 to another scenario. However, if the modernization engineer is using a modeling environment which provides a business rule view, (s)he could also have available for him(her) a moving business rule refactoring. In this case, the natural propagation would be to transfer the corresponding classes from one package to another. Therefore, we can see that in some cases there is bidirectional flow, which can be started from any point.  

  A certain particularity of our approach is that the required input is two KDM instances; the original and the refactored. As the refactoring activity is not part of our approach, there is no guarantee that other modernization engineers will implement refactorings that result in two models. Other possibilities would be having other kinds of inputs, such as an annotated KDM, or an extended KDM, or an stereotyped KDM. However, this will require modifications in our first step. 
 
Although our main focus along the paper had been on the lower-level refactorings and botton-up propagations, in our case study we decided to start an investigation on top-down propagations employing the \textit{Extract Layer} refactoring. The results seems to indicate that our propagation module is able to propagate correctly even in this case, as shown in Table~\ref{tab:prop}. However, we intend to deepen much more in this line of thought in a future work. Similarly, during the experiment carried out our MDI Algorithm seem to identify correctly the affected KDM elements, it reached a good level of precision and recall. However, we aim to pursue another mining techniques in future work.


%Although our main focus throughout the paper was lower-level refactorings and botton-up propagations, in our case study we investigated top-down propagations employing the \textit{Extract Layer} refactoring. The results seems to indicate that our propagation module is able to propagate correctly even in this case, as shown in Table~\ref{tab:prop}. However, we aim to pursue this approach in future work.

%The main contributions are: i) a DI Algorithm to identify all KDM model elements that need to be updated when a specific refactoring is performed, ii) a propagation technique approach, and (iii) a support and preliminary infrastructure for allowing the creation of refactorings for KDM without worrying about he propagation of changes.

Summing up, the idea behind KDM is that the community starts to create parsers and tools that work exclusively over KDM instances; thus, every tool/algorithm that takes KDM as input can be considered platform and language-independent. For instance, a refactoring catalogue for KDM~\cite{IRIDurelliCatalogo}, a crosscutting concerns mining for KDM models~\cite{dani_san}, architectural conformance checking for KDM models, could be applied to any system implemented in any language. In the same line of thought , an important point is about the reusability of the algorithms and transformations developed in this work. All of them are strictly focused on the KDM syntax, what makes them language and platform independent. So, we could use our propagation approach during the refactoring of systems implemented in C++, C\#, Cobol, etc in order to keep all their views synchronized.