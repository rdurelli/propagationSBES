%!TEX root = /Users/rafaeldurelli/Dropbox/Artigos Elaborados/KDM propagation_2015/sbes_2015_kdm_propagation/sbes2015_kdm_propagation.tex

%In 2003 the Object Management Group (OMG) created a task force called Architecture Driven Modernization Task Force (ADMTF). It aims to analyze and evolve typical reengineering processes, formalizing them and making them to be supported by models [2]. ADM advocates the conduction of reengineering processes following the principles of Model-Driven Architecture (MDA) [22][2], i.e., all software artifacts considered along with the process are models.                                       	

%According to OMG the most important artifact provided by ADM is the Knowledge Discovery Metamodel (KDM). By means of it, it is possible to represent different system abstraction levels by using its models, such as source code (Source and Code models), Actions (Action model), Architecture (Structure Model) and Business Rules (Conceptual Model). The idea behind KDM is that the community starts to create parsers and tools that work exclusively over KDM instances; thus, every tool that takes KDM as input can be considered platform and language-independent, propitiating interchange among tools. For instance, a refactoring catalogue for KDM can be used for refactoring systems implemented in different languages. 

%Central to modernization processes are the refactorings. Refactorings are .....  However, most of existing model-based refactorings do not cope with propagation of the refactoring changes across other dependent abstraction levels, keeping all models synchronized [ , , , , ]

%	In this paper we present Propagation-Aware Refactorings (PARef), an approach for updating dependent models when specific elements are refactored.


Architecture-Driven Modernization (ADM) advocates the conduction of reengineering processes following the principles of Model Driven Architecture (MDA)~\cite{1686216, Heckel2008, 7051941, IRIDurelliCatalogo}, i.e., all software artifacts considered along the process are models. ADM-based modernization starts with a reverse engineering phase to recuperate a model representation of the legacy system; proceeds by applying refactorings over the recuperated model and finalize by generating the modernized system.

Knowledge Discovery Meta-model (KDM) is the most important meta-model provided by ADM. Its main characteristics are: i) it is an ISO-IEC standard since 2010 (ISO/IEC 19506); ii) it is platform/language independent, and iii) it is able to represent different views of the system and retain the dependencies among them by using its meta-models. This third point is possible thanks to several KDM meta-models/packages that are focused on specific views or abstraction levels. Examples are:  source-code (Code meta-model), behaviors (Action meta-model), architecture (Structure meta-model), business rules (Conceptual meta-model), data (Data meta-model), events (Event meta-model), GUI (UI meta-model) and deployment (platform meta-model).  

Unlike existing meta-models, KDM puts together all the  views of the system in an unique place, so, it can be considered as family of meta-models, since all of them share a consistent and homogeneously terminology (meta-model sintax)~\cite{murduck}. %The idea behind KDM is that the community starts to create parsers and tools that work exclusively over KDM instances; thus, every tool/algorithm that takes KDM as input can be considered platform and language-independent. For instance, a refactoring catalogue for KDM can be used for refactoring systems implemented in any language~\cite{IRIDurelliCatalogo}.

Refactoring activities are central to any modernization process. Refactorings are defined as the process of modifying the internal structure of software without changing its external observable behavior\cite{refactImpro}. When a system is represented by using several different models, a common accident that arises during refactorings is  to desynchronize the models, ending up with inconsistent models/views after the refactoring. To solve this problem, an alternative is to apply a ``change propagation"  technique, whose goal is to identify and update all the model elements dependent on the refactored element in order to keep all the views synchronized~\cite{4440135, Mens:2006:TMT:1706639.1706924, Mens:2006_NEW, Mens:2007}.

Change propagation can be classified in two types: dynamic and static. Dynamic  Change Propagation has been the main focus for decades, trying to preserve the system behavior when refactoring a static model. On the other hand, Static Change Propagation (SCP), which is the focus of this work, has only more recently received attention, but it is also possible to find a number of research on this line of thought~\cite{4440135, Mens:2006:TMT:1706639.1706924, Mens:2006_NEW, Mens:2007}. The goal of this type of propagation is updating a static model/view (that usually represents a view of the system) after refactoring another static model/view.  

Most of the existing research on SCP concentrates on propagating changes in different and external models, for example, when changing an UML class model, changes are propagated to a data model, usually from another vendor~\cite{Supporting_change_propagation_in_UML_models}. Besides, most of the SCP solutions are specific to proprietary models, preventing or making difficult their application in other models, like KDM ~\cite{4440135, Mens:2007}. To the best of our knowledge, up to this moment, there is no research concentrated on investigating change propagation in KDM.

In this paper we present a tool-supported approach for propagating changes when refactoring KDM models/views. Using our approach, modernization engineers can concentrate just on the development of the refactorings, without worrying about the change propagation, which is a time-consuming and error-prone task. Our approach is supported by an Eclipse plug-in that allows model refactorings be executed while the propagations are applied in a transparent way.


%The workflow of our approach is the following: firstly the modernization engineer either creates or reuses an specific KDM refactoring, this refactoring can be defined by means of a set of model transformations languages such as: ATL, QVT, ETL, etc. Then the engineer apply such refactoring in a KDM instance. Then after that, our approach performs its three steps. 
The workflow of our approach starts by considering the existence of some KDM-specific refactorings that can be applied in a KDM instance representing a system. As long as the modernization engineer had applied the refactoring, our three-steps approach can be triggered. The first step performs a diff between the refactored KDM instance with the original KDM instance (the instance before engineer applies any KDM refactoring). The output of this step is a list of all instances of KDM meta-classes that suffered a modification when compared to the original model. After that, the second step is performed, which automatically uses the list provided by the earlier step as input to our Mining Dependents Identification Algorithm. This algorithm identifies all instances of KDM meta-classes that are dependent on the instances provided by the first step and it also supplies a new list as output.
%
%
%
%This algorithm aims to identify all KDM model elements that were modified by a refactoring, this step also uses a set of queries defined using JPath to assist the mining algorithm. Similarly to the first step, the second one also provides a list as output that contains all KDM models elements that were affected/modified by a refactoring. 
Finally, the third step automatically uses the output from the last step along with a set of pre-defined ATLs (transformations rules) to realize the change propagation throughout KDM levels. We have implemented the approach in a generic way as a decoupled module, which can be coupled to existing KDM refactorings. 


%Furthermore, our approach performs a diff between the generated KDM refactored instance with the original KDM instance (the instance before one applies the KDM refactoring). The output is a list that contains all KDM elements involved in the KDM refactoring. After that, two important steps are performed : i) automatically our approach uses this list as input to our Java mining algorithm that identifies all KDM model elements that were modified by a refactoring using JPath and ii) a set of ATLs perform one or more model transformations that characterize the change propagations. 

We have carried out an experiment and a case study in order to evaluate our three-step approach. The former was performed to evaluate the second step of our approach, i.e., analyze the effectiveness of our Mining Dependents Identification Algorithm for with respect to precision and recall. The latter was carried out to evaluate the effectiveness of our set of pre-defined ATLs (change propagation), i.e., the case study verified if all propagations were performed corrected after to apply a set of KDM refactorings.

The remaining of this paper is organized as follows. Section~\ref{sec:background} presents the basic concepts on ADM and KDM. Section~\ref{sec:running_example} describes a running example. 
%
%
%Section~\ref{sec:background} presents all needed background on ADM and KDM. 
 Section~\ref{sec:the_approach} shown the proposed approach. Section~\ref{sec:case_study} presents a case study and in Section~\ref{sec:evaluation} an empirical evaluation is presented. In Section~\ref{sec:related_work} there are related works. %In Section~\ref{sec:a_brief_discussion} a discussion is presented. 
Finally, Section~\ref{sec:conclusion} concludes the paper summarizing the contributions and highlighting some future work.


%-----------------------------------------------------------

%In 2003 the Object Management Group (OMG) created a task force called Architecture Driven Modernization Task Force (ADMTF). The goal was to analyze and evolve typical reengineering processes, formalizing them and making them to be supported by models~\cite{1686216}. The result of this effort was the creation of Architecture-Driven Modernization (ADM), which advocates the conduction of reengineering processes following the principles of Model Driven Architecture (MDA)~\cite{Heckel2008, Andrade:2005, Reus:2006}, i.e., all software artifacts considered along with the process are models. Therefore, a typical ADM-based modernization process starts with a reverse engineering phase to recuperate a model representation of the system; proceeds by applying refactorings over the recuperated model and finalize by a forward engineering phase where the modernized system is generated.

%Knowledge Discovery Metamodel (KDM) is the most important metamodel provided by ADM. Its main characteristics are: i) it is an ISO-IEC standard since 2010 (ISO/IEC 19506); ii) it is platform/language independent, and ii) it is able to represent different views of the same system and retain the dependencies among them by using specific metaclasses. This third point is possible thanks to several internal KDM metamodels/packages that are focused on specific views or abstraction levels, such as  source-code (Code metamodel), behaviors (Action metamodel), architecture (Structure metamodel), business rules (Conceptual metamodel), database (Data metamodel), events (Event metamodel), Graphical User Interface (GUI) (UI metamodel) and deployment (platform metamodel).  

%It is well known that refactoring activities are central to modernization processes. Refactorings are defined as the process of modifying the internal structure of software without changing its external observable behavior~\cite{refactImpro}. Behavior preservation in refactoring activities has received a lot of attention for years, both in source code and in models~\cite{4440135, Mens:2006:TMT:1706639.1706924, Mens:2006_NEW, Mens:2007}. One of the known problems when refactoring models is change propagation, i.e., the modifications that need to be done in model elements that are dependent on the refactored model element. Although the behavior preservation is harder to check and characterize when dealing with models, there are works that present proposals of keeping the behavior models updated when static models are refactored~\cite{ICSOFT2014_Winetzhammer}. Most of the works propose solutions to propagate changes across different metamodels not in the same metamodel. 

%However, although some research has been conducted on the theme of change propagation in models~\cite{4440135, Mens:2006:TMT:1706639.1706924, Mens:2006_NEW, Mens:2007, ICSOFT2014_Winetzhammer}, none of them have devoted attention on a metamodel like KDM, which groups several metamodels under a unique place and already provide metaclasses for retaining the dependences among these models. In most cases, the related works concentrate on propagating changes in a metamodel different from where had occurred the modification. Besides, the concentration of some of them are in behavior preservation, an aspect that is out of the scope of this work.

%However, although some research has been conducted on the theme of change propagation in models~\cite{4440135, Mens:2006:TMT:1706639.1706924, Mens:2006_NEW, Mens:2007, ICSOFT2014_Winetzhammer}, none of them has devoted attention on a metamodel like KDM, which groups several metamodels under a unique place and already provide metaclasses for retaining the dependences among these models. In most cases, the related works concentrate on propagating changes in a different metamodel from where had occured the modification. Besides, the concentration of some of them are in behavior preservation, an aspect that is out of the scope of this work. Furthermore, up to this moment, few research has been done on KDM refactorings~\cite{IRIDurelliCatalogo, 7051941}, limiting the dissemination and adoption of ADM. We believe that our change propagation approach will foster the creation and research on KDM refactorings. 

%In this paper we present an approach for propagating changes when refactoring KDM model instances. The main goal is to guarantee the global system representation keep synchronized along with the refactoring activities; which are much common during modernization processes. Our approach runs in three steps: i) a search algorithm identifies all the KDM metaclasses dependent on the refactored elements and ii) an ATL Transformation Language (ATL) that performs the model transformation/refactoring, and iii) another ATL created to propagate all the changes throughout all KDM's view. This last step was implemented in a generic way - as a decoupled module, which can be coupled to existing refactorings. In this way, existing users can write KDM refactorings in ATL without worrying about the change propagation. The only task is to provide for our component the input it needs to conduct the propagation.

%In this paper we present an approach for propagating changes when refactoring KDM model instances. The main goal is to guarantee the global system representation keep synchronized along with the refactoring activities; which are much common during modernization processes. Our approach runs in three steps: i) a mining algorithm identifies all KDM metaclasses that need to be updated when refactoring a specific KDM metaclass, ii) an ATL Transformation Language (ATL) that performs the intended refactoring, and iii) another ATL that performs one or more model transformations that characterize change propagation. We have implemented the approach in a generic way as a decoupled module, which can be coupled to existing refactorings. In this way, existing users can write KDM refactorings in ATL without worrying about the change propagation. The only task is to provide for our component the input it needs to conduct the propagation.

%The main contributions are: i) a mining algorithm to identify all KDM metaclasses that need to be updated when a specific refactoring is performed, ii) a set of refactoring devised to KDM domain, iii) a propagation technique approach, and (iv) a support and preliminary infrastructure for allowing the creation of refactorings for kdm.

%This paper is structured as follows: In Section~\ref{sec:background} the notion related to ADM and KDM, their details and a system's description that was instantiated in KDM are showed.
%
%
%Section~\ref{sec:background} presents all needed background on ADM and KDM. 
%In Section~\ref{sec:motivation_and_running_example} a motivation is presented. Section~\ref{sec:the_approach} shown the proposed approach. In Section~\ref{sec:evaluation}, an empirical evaluation is presented. In Section~\ref{sec:related_work} there are related works and in Section~\ref{sec:conclusion} there are the conclusions.

